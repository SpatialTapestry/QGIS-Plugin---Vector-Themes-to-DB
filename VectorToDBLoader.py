# -*- coding: utf-8 -*-
"""
/***************************************************************************
 VectorToDBLoader
                                 A QGIS plugin
 Loads Vector Themes to Databases
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-12-27
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Roger Merritt / Spatial Tapestry
        email                : roger@SpatialTapesry.com.au
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

# An "illegal" identifier has to be quoted in Postgres (and SQL).
# The function format() has a special place holder for identifiers and will return a quoted identifier
# if anything is non-standard:
# So select format('%I', 'foo') returns foo.
# But select format('%I', 'foo bar') returns "foo bar"

Some Postgres code to get started with (PGADMIN4):
CREATE DATABASE gisdb WITH OWNER = postgres ENCODING = 'UTF8' TABLESPACE = pg_default CONNECTION LIMIT = 300;
CREATE ROLE rogermsu LOGIN PASSWORD 'rogermsu' SUPERUSER INHERIT CREATEDB CREATEROLE NOREPLICATION;
CREATE SCHEMA testdata AUTHORIZATION rogermsu;

Some Oracle code to get started with (SQL Developer)
Note: With Oracle each user has their own schema
Enter user-name: system
Enter password:
Last Successful login time: Wed Jan 10 2024 14:33:56 +08:00
Connected to:
Oracle Database 21c Express Edition Release 21.0.0.0.0 - Production
Version 21.3.0.0.0
SQL> create user drrog identified by drrog;
create user drrog identified by drrog
            *
ERROR at line 1:
ORA-65096: invalid common user or role name
SQL> alter session set "_ORACLE_SCRIPT"=true;
Session altered.
SQL> create user drrog identified by drrog;
User created.
SQL>
-- USER SQL
CREATE USER "drrog" IDENTIFIED BY "drrog"  ;
-- ROLES
GRANT "CONNECT" TO "DRROG" ;
GRANT "DBA" TO "DRROG" ;
-- SYSTEM PRIVILEGES
GRANT ALTER ANY TABLE TO "DRROG" ;
GRANT DROP ANY TABLE TO "DRROG" ;
GRANT INSERT ANY TABLE TO "DRROG" ;
GRANT CREATE ANY TABLE TO "DRROG" ;



pip install -U psycopg2
pip install -U oracledb
pip install -U pyodbc
https://docs.devart.com/odbc/sqlserver/using_odbc_driver.htm
sudo apt-get install odbcinst1debian2 libodbc1 odbcinst unixodbc
https://www.devart.com/odbc/sqlserver/download.html
https://docs.devart.com/odbc/sqlserver/configuring_odbc_dsn_on_linux.htm
grant permissions to the user


On Windows:
PYTHONPATH
C:\Program Files\QGIS 3.34.1\apps\qgis\python;C:\Program Files\QGIS 3.34.1\apps\qgis\python\plugins;C:\Program Files\QGIS 3.34.1\apps\Qt5\plugins;C:\Program Files\QGIS 3.34.1\share\gdal;


 """
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .VectorToDBLoader_dialog import VectorToDBLoaderDialog
import os
import os.path

import datetime

from qgis.core import *
from qgis.gui import *
from qgis.utils import *

import psycopg2
connPGS: psycopg2
import oracledb
connORA: oracledb
import pyodbc
connDEV: pyodbc


myGBL = {}
#myGBL.update({'ConFileName': os.path.expanduser( '~' ) + '/ST_SDL.Config'}) 
#myGBL.update({'LogFileName': os.path.expanduser( '~' ) + '/aaa.log'}) 

class VectorToDBLoader:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'VectorToDBLoader_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&VectorToDBLoader')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('VectorToDBLoader', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToVectorMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/VectorToDBLoader/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Vector To DB Loader'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginVectorMenu(
                self.tr(u'&VectorToDBLoader'),
                action)
            self.iface.removeToolBarIcon(action)

    def select_Btn_SaveProjectFile(self):
        try:
            my_Save_Project_File(self)
        except Exception as err:
            self.iface.messageBar().pushMessage(
            "Failure", err,
            level=Qgis.Success, duration=3)


    def select_PG_TestDB(self):
        # conn01 = psycopg2.connect("dbname=suppliers user=postgres password=postgres")
        update_myGBL(self)
        try:
            sqlStr = "create table testtable(stid NUMBER Primary Key, firstname VARCHAR2(20) NOT NULL)"
            if myGBL['DatabaseType'] == "PGS":
                connPGS = returnPGS(**myGBL)
                cursor = connPGS.cursor()
                cursor.execute(sqlStr)
                self.iface.messageBar().pushMessage(
                    "Success", myGBL['DatabaseType'] + " create table called",
                    level=Qgis.Success, duration=10)

            if myGBL['DatabaseType'] == "ORA":
                connORA = returnORA(**myGBL)
                cursor = connORA.cursor()
                cursor.execute(sqlStr)
                self.iface.messageBar().pushMessage(
                    "Success", myGBL['DatabaseType'] + " create table called",
                    level=Qgis.Success, duration=10)

            if myGBL['DatabaseType'] == "ORD":
                connDEV = returnORD(**myGBL)
                cursor = connORA.cursor()
                cursor.execute(sqlStr)
                self.iface.messageBar().pushMessage(
                    "Success", myGBL['DatabaseType'] + " create table called",
                    level=Qgis.Success, duration=10)

            if myGBL['DatabaseType'] == "MSS":
                connDEV = returnMSS(**myGBL)
                cursor = connDEV.cursor()
                cursor.execute(sqlStr)
                self.iface.messageBar().pushMessage(
                    "Success", myGBL['DatabaseType'] + " create table called",
                    level=Qgis.Success, duration=10)

            my_Save_Project_File(self)

            self.iface.messageBar().pushMessage(
                "Success", myGBL['DatabaseType'] + "_TestDB pressed ",
                level=Qgis.Success, duration=3)
        except Exception as err:
            error_obj = err.args
            self.iface.messageBar().pushMessage(
            "Failure " + str(error_obj), err,
            level=Qgis.Success, duration=13)

    def select_btn_Delete_SelectedThemes(self):
        try:
            DatabaseType = myGBL['DatabaseType']
            Output2 = myGBL['Output2']
            if Output2 == "Serv" or Output2 == "Both":
                if myGBL['DatabaseType'] == "PGS":
                    connPGS = returnPGS(**myGBL)
                if myGBL['DatabaseType'] == "ORA":
                    connOra = returnORA(**myGBL)
                if myGBL['DatabaseType'] == "ORD":
                    connOrD = returnORD(**myGBL)
                if myGBL['DatabaseType'] == "MSS":
                    connDEV = returnMSS(**myGBL)
            myLogFileName = os.path.expanduser( '~' ) + "/log._DeleteThemeReport"
            with open(myLogFileName, 'w') as log_file:
                log_file.close
            with open(os.path.expanduser( '~' ) + "/sql._DeleteThemeReport", 'w') as delete_file:
                for SelLayer in iface.layerTreeView().selectedLayers():
                    svl:QgsVectorLayer
                    svl = SelLayer
                    svlname = svl.name().lower()
                    if SelLayer.type() == QgsMapLayer.VectorLayer:
                        layers = QgsProject.instance().mapLayers().values()
                        for layer in layers:
                            vl:QgsVectorLayer
                            vl = layer
                            vlname = vl.name().lower()
                            if layer.type() != QgsMapLayer.VectorLayer:
                                continue
                            elif vlname == svlname:
                                layername = vl.name().lower().replace(".","_")
                                if DatabaseType == "PGS":
                                    layername = myGBL['PG_Schema'] + "." + layername
                                sqlStr = "DROP TABLE " + layername
                                if Output2 == "File" or Output2 == "Both":
                                    delete_file.write(sqlStr + ";" + '\n')
                                if Output2 == "Serv" or Output2 == "Both":
                                    if DatabaseType == "PGS":
                                        runPGSSQL(sqlStr, connPGS, myLogFileName)
                                    elif DatabaseType == "ORA":
                                        runORASQL(sqlStr, connOra, myLogFileName)
                                    elif DatabaseType == "ORD":
                                        runORDSQL(sqlStr, connOrD, myLogFileName)
                                    elif DatabaseType == "MSS":
                                        runDEVSQL(sqlStr, connDEV, myLogFileName)
                delete_file.close

        except Exception as err:
            self.iface.messageBar().pushMessage("FailureX", err, level=Qgis.Success, duration=3)
            return False
       
    def select_btn_Load_SelectedThemes(self):
        try:
            with open(os.path.expanduser( '~' ) + "/log._ImportThemeReport", 'w') as report_file:
                report_file.close
                
                # report_file.write("There are " + str(iface.layerTreeView().selectedLayers().count()) + " Selected Themes" + '\n')
                for SelLayer in iface.layerTreeView().selectedLayers():
                    svl:QgsVectorLayer
                    svl = SelLayer
                    svlname = svl.name().lower()
                    # report_file.write("Looking for Sel Theme " + svlname + '\n')

                    if SelLayer.type() == QgsMapLayer.VectorLayer:
                        # report_file.write("Sel Theme is a QgsMapLayer.VectorLayer " + svlname + '\n')
                        layers = QgsProject.instance().mapLayers().values()
                        gotit = False
                        for layer in layers: # + str(layer.parent()) + ", " 
                            vl:QgsVectorLayer
                            vl = layer
                            vlname = vl.name().lower()
                            # report_file.write("Looking at Theme " + vlname + '\n')
                            if layer.type() != QgsMapLayer.VectorLayer:
                                # Ignore this layer as it's not a vector
                                continue
                            elif layer.featureCount() == 0:
                                # There are no features - skip
                                continue
                            elif vlname == svlname:
                                # report_file.write("Got a match Sel Theme " + svlname + " " + vlname + '\n')
                                gotit = True
                                import_raw_theme(self, layer, **myGBL)

        except Exception as err:
            self.iface.messageBar().pushMessage("FailureX", err, level=Qgis.Success, duration=3)
            return False

    def rb_PostGIS_pushed(self):
        myGBL.update({'DatabaseType': "PGS"}) 
        myGBL.update({'ConFileName': os.path.expanduser( '~' ) + '/PGS_ST_SDL.Config'}) 
        #self.FWProjectFile.setText(myGBL['ConFileName'])
        self.dlg.label_12.setText(myGBL['DatabaseType'] + " and " + myGBL['Output2']) 
        showProjectFile(self)

    def rb_Oracle_pushed(self):
        myGBL.update({'DatabaseType': "ORA"}) 
        myGBL.update({'ConFileName': os.path.expanduser( '~' ) + '/ORA_ST_SDL.Config'}) 
        #self.FWProjectFile.setText(myGBL['ConFileName'])
        self.dlg.label_12.setText(myGBL['DatabaseType'] + " and " + myGBL['Output2']) 
        showProjectFile(self)

    def rb_OracleDevart_pushed(self):
        myGBL.update({'DatabaseType': "ORD"}) 
        myGBL.update({'ConFileName': os.path.expanduser( '~' ) + '/ORD_ST_SDL.Config'}) 
        #self.FWProjectFile.setText(myGBL['ConFileName'])
        self.dlg.label_12.setText(myGBL['DatabaseType'] + " and " + myGBL['Output2']) 
        showProjectFile(self)

    def rb_MSSQL_pushed(self):
        myGBL.update({'DatabaseType': "MSS"}) 
        myGBL.update({'ConFileName': os.path.expanduser( '~' ) + '/MSS_ST_SDL.Config'}) 
        #self.FWProjectFile.setText(myGBL['ConFileName'])
        self.dlg.label_12.setText(myGBL['DatabaseType'] + " and " + myGBL['Output2']) 
        showProjectFile(self)
    
    def update_TB_12(self):
        if not self.dlg.CB_Write2File.isChecked() and not self.dlg.CB_Execute2DB.isChecked():
            self.dlg.CB_Write2File.setChecked(True)
            myGBL.update({'Output2': "File"}) 
        if self.dlg.CB_Write2File.isChecked() and not self.dlg.CB_Execute2DB.isChecked():
            myGBL.update({'Output2': "File"}) 
        elif not self.dlg.CB_Write2File.isChecked() and self.dlg.CB_Execute2DB.isChecked():
            myGBL.update({'Output2': "Serv"}) 
        elif self.dlg.CB_Write2File.isChecked() and self.dlg.CB_Execute2DB.isChecked():
            myGBL.update({'Output2': "Both"}) 
        self.dlg.label_12.setText(myGBL['DatabaseType'] + " and " + myGBL['Output2']) 
        self.dlg.btn_Load_QGISThemes.setText("Process the QGIS Selected Themes to " + myGBL['Output2'])
        self.dlg.btn_Delete_QGISThemes.setText("Delete the QGIS Selected Themes from " + myGBL['Output2'])

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            myGBL.update({'ConFileName': os.path.expanduser( '~' ) + '/PGS_ST_SDL.Config'}) 
            self.dlg = VectorToDBLoaderDialog()
            self.dlg.Btn_SaveProjectFile.clicked.connect(self.select_Btn_SaveProjectFile)
            self.dlg.btn_Load_QGISThemes.clicked.connect(self.select_btn_Load_SelectedThemes)
            self.dlg.btn_Delete_QGISThemes.clicked.connect(self.select_btn_Delete_SelectedThemes)
            self.dlg.rb_PostGIS.clicked.connect(self.rb_PostGIS_pushed)
            self.dlg.rb_Oracle.clicked.connect(self.rb_Oracle_pushed)
            self.dlg.rb_OracleDevart.clicked.connect(self.rb_OracleDevart_pushed)
            self.dlg.rb_MSSQL.clicked.connect(self.rb_MSSQL_pushed)
            self.dlg.CB_Execute2DB.clicked.connect(self.update_TB_12)
            self.dlg.CB_Write2File.clicked.connect(self.update_TB_12)
            self.dlg.PG_TestDB.clicked.connect(self.select_PG_TestDB)

            self.dlg.rb_PostGIS.setChecked(True)

            myGBL.update({'DatabaseType': "PGS"}) 
            myGBL.update({'Output2': "Both"}) 
            self.dlg.label_12.setText(myGBL['DatabaseType'] + " and " + myGBL['Output2']) 
            self.dlg.btn_Load_QGISThemes.setText("Process the QGIS Selected Themes to " + myGBL['Output2'])
            self.dlg.btn_Delete_QGISThemes.setText("Delete the QGIS Selected Themes from " + myGBL['Output2'])

        # show the dialog
        self.dlg.show()

        if os.path.exists(myGBL['ConFileName']):
            showProjectFile(self)
    
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

def update_myGBL(self):
    myGBL.update({'PG_IPAddress': self.dlg.PG_IPAddress.text()}) 
    myGBL.update({'PG_DBName': self.dlg.PG_DBName.text()}) 
    myGBL.update({'PG_Username': self.dlg.PG_Username.text()}) 
    myGBL.update({'PG_Password': self.dlg.PG_Password.text()}) 
    myGBL.update({'PG_Port': self.dlg.PG_Port.text()}) 
    myGBL.update({'PG_Schema': self.dlg.PG_SchemaName.text()}) 



def showProjectFile(self):
    try:
        if os.path.exists(myGBL['ConFileName']):
            with open(myGBL['ConFileName'], 'r') as input_file:
                lines = input_file.readlines()
                
                if len(lines) > 0:
                    self.dlg.PG_IPAddress.setText(lines[0].replace('\n','').split('=')[1])
                if len(lines) > 1:
                    self.dlg.PG_DBName.setText(lines[1].replace('\n','').split('=')[1])
                if len(lines) > 2:
                    self.dlg.PG_Username.setText(lines[2].replace('\n','').split('=')[1])
                if len(lines) > 3:
                    self.dlg.PG_Password.setText(lines[3].replace('\n','').split('=')[1])
                if len(lines) > 4:
                    self.dlg.PG_Port.setText(lines[4].replace('\n','').split('=')[1])
                if len(lines) > 5:
                    self.dlg.PG_SchemaName.setText(lines[5].replace('\n','').split('=')[1])

                update_myGBL(self)
                
                #self.dlg.mQgsProjectionSelectionWidget_Table.setCrs(QgsCoordinateReferenceSystem('EPSG:3111'))
                if len(lines) > 6:
                    SRID_Table = lines[6].replace('\n','').split('=')[1]
                    self.dlg.mQgsProjectionSelectionWidget_Table.setCrs(QgsCoordinateReferenceSystem(SRID_Table))
                    myGBL.update({'tableSRID': SRID_Table}) 

                if len(lines) > 7:
                    myGBL.update({'DatabaseType': lines[7].replace('\n','').split('=')[1]}) 
                if len(lines) > 8:
                    myGBL.update({'Output2': lines[8].replace('\n','').split('=')[1]}) 

                if myGBL['DatabaseType'] == "PGS":
                    self.dlg.rb_PostGIS.setChecked(True)
                    self.dlg.PG_SchemaName.setEnabled(True)
                if myGBL['DatabaseType'] == "ORA":
                    self.dlg.rb_Oracle.setChecked(True)
                    self.dlg.PG_SchemaName.setEnabled(False)
                if myGBL['DatabaseType'] == "ORD":
                    self.dlg.rb_OracleDevart.setChecked(True)
                    self.dlg.PG_SchemaName.setEnabled(False)
                if myGBL['DatabaseType'] == "MSS":
                    self.dlg.rb_MSSQL.setChecked(True)
                    self.dlg.PG_SchemaName.setEnabled(True)
                if myGBL['Output2'] == "File":
                    self.dlg.CB_Write2File.setChecked(True)
                    self.dlg.CB_Execute2DB.setChecked(False)
                if myGBL['Output2'] == "Serv":
                    self.dlg.CB_Execute2DB.setChecked(True)
                    self.dlg.CB_Write2File.setChecked(False)
                if myGBL['Output2'] == "Both":
                    self.dlg.CB_Write2File.setChecked(True)
                    self.dlg.CB_Execute2DB.setChecked(True)
 
            QGeomTypes = [("Point", QgsWkbTypes.PointGeometry, QgsWkbTypes.Point),
                ("LineString", QgsWkbTypes.LineGeometry, QgsWkbTypes.LineString),
                ("Polygon", QgsWkbTypes.PolygonGeometry, QgsWkbTypes.Polygon),
                ("MultiPoint", QgsWkbTypes.PointGeometry, QgsWkbTypes.MultiPoint),
                ("MultiLineString", QgsWkbTypes.LineGeometry, QgsWkbTypes.MultiLineString),
                ("MultiPolygon", QgsWkbTypes.PolygonGeometry, QgsWkbTypes.MultiPolygon),
                ("PointZ", QgsWkbTypes.PointGeometry, QgsWkbTypes.PointZ),
                ("LineStringZ", QgsWkbTypes.LineGeometry, QgsWkbTypes.LineStringZ),
                ("PolygonZ", QgsWkbTypes.PolygonGeometry, QgsWkbTypes.PolygonZ),
                ("MultiPointZ", QgsWkbTypes.PointGeometry, QgsWkbTypes.MultiPointZ),
                ("MultiLineStringZ", QgsWkbTypes.LineGeometry, QgsWkbTypes.MultiLineStringZ),
                ("MultiPolygonZ", QgsWkbTypes.PolygonGeometry, QgsWkbTypes.MultiPolygonZ),
                ("PointM", QgsWkbTypes.PointGeometry, QgsWkbTypes.PointM),
                ("LineStringM", QgsWkbTypes.LineGeometry, QgsWkbTypes.LineStringM),
                ("PolygonM", QgsWkbTypes.PolygonGeometry, QgsWkbTypes.PolygonM),
                ("MultiPointM", QgsWkbTypes.PointGeometry, QgsWkbTypes.MultiPointM),
                ("MultiLineStringM", QgsWkbTypes.LineGeometry, QgsWkbTypes.MultiLineStringM),
                ("MultiPolygonM", QgsWkbTypes.PolygonGeometry, QgsWkbTypes.MultiPolygonM),
                ("PointZM", QgsWkbTypes.PointGeometry, QgsWkbTypes.PointZM),
                ("LineStringZM", QgsWkbTypes.LineGeometry, QgsWkbTypes.LineStringZM),
                ("PolygonZM", QgsWkbTypes.PolygonGeometry, QgsWkbTypes.PolygonZM),
                ("MultiPointZM", QgsWkbTypes.PointGeometry, QgsWkbTypes.MultiPointZM),
                ("MultiLineStringZM", QgsWkbTypes.LineGeometry, QgsWkbTypes.MultiLineStringZM),
                ("MultiPolygonZM", QgsWkbTypes.PolygonGeometry, QgsWkbTypes.MultiPolygonZM),
                ("Point25D", QgsWkbTypes.PointGeometry, QgsWkbTypes.Point25D),
                ("LineString25D", QgsWkbTypes.LineGeometry, QgsWkbTypes.LineString25D),
                ("Polygon25D", QgsWkbTypes.PolygonGeometry, QgsWkbTypes.Polygon25D),
                ("MultiPoint25D", QgsWkbTypes.PointGeometry, QgsWkbTypes.MultiPoint25D),
                ("MultiLineString25D", QgsWkbTypes.LineGeometry, QgsWkbTypes.MultiLineString25D),
                ("MultiPolygon25D", QgsWkbTypes.PolygonGeometry, QgsWkbTypes.MultiPolygon25D),
                ("None", QgsWkbTypes.NullGeometry, QgsWkbTypes.NoGeometry)]
            myGBL.update({'QGeomTypes': QGeomTypes}) 

            self.dlg.label_12.setText(myGBL['DatabaseType'] + " and " + myGBL['Output2']) 
            self.dlg.btn_Load_QGISThemes.setText("Process the QGIS Selected Themes to " + myGBL['Output2'])
            self.dlg.btn_Delete_QGISThemes.setText("Delete the QGIS Selected Themes from " + myGBL['Output2'])

            self.iface.messageBar().pushMessage(
                "Config File Loaded:", myGBL['ConFileName'],
                level=Qgis.Success, duration=3)
    
            input_file.close()
            return True
        
    except Exception as err:
        self.iface.messageBar().pushMessage("Failure", err, level=Qgis.Success, duration=3)
        return False


def import_raw_theme(self, aLayer: QgsVectorLayer, **myGBL):

    my_Save_Project_File(self)

    with open(os.path.expanduser( '~' ) + "/log.aaa", 'w') as logaaa_file:
        logaaa_file.close

    vl:QgsVectorLayer
    vl = aLayer
    layername = vl.name().lower().replace(".","_")
    themeSRID = str(vl.sourceCrs())
    themeSRID = themeSRID.replace("<QgsCoordinateReferenceSystem: ","").replace(">","").replace("EPSG:","")
    tableSRID = myGBL['tableSRID'].replace("EPSG:","")
    DatabaseType = myGBL['DatabaseType']
    Output2 = myGBL['Output2']
    SQLFileName = os.path.expanduser( '~' ) + "/" +  DatabaseType + "_" + layername + ".sql"
    myGBL.update({'LogFileName': os.path.expanduser( '~' ) + "/" +  DatabaseType + "_" + layername + ".txt"}) 

    with open(myGBL['LogFileName'], 'w') as log_file:
        log_file.write("All errors for: " + DatabaseType + "_" + layername)
        log_file.close

    #if Output2 == "Serv" or Output2 == "Both":
    if myGBL['DatabaseType'] == "PGS":
        connPGS = returnPGS(**myGBL)

    if myGBL['DatabaseType'] == "ORA":
        connOra = returnORA(**myGBL)
        #connOra.autocommit = True

    if myGBL['DatabaseType'] == "ORD":
        connOrD = returnORD(**myGBL)
        #connOra.autocommit = True

    if myGBL['DatabaseType'] == "MSS":
        connDEV = returnMSS(**myGBL)
        #connDEV.autocommit = True

    with open(SQLFileName, 'w') as outSQL_file:
        
        dateBeg = datetime.datetime.now()
        newTblName = layername
        if DatabaseType == "PGS":
            newTblName = myGBL['PG_Schema'] + "." + layername
        if DatabaseType == "MSS" and myGBL['PG_Schema'] != "":
            newTblName = myGBL['PG_Schema'] + "." + layername

        line = "-- " + layername + " has " + str(vl.featureCount()) + " features..." + '\n'
        outSQL_file.write(line)
        ncount = 0
        ora2Long = 0
        sqlStr = ""
        insStr = ""
#create schema test123 AUTHORIZATION rogermsu;

        if DatabaseType == "PGS":
            sqlStr = "create schema if not exists " + myGBL['PG_Schema'] + " AUTHORIZATION " + myGBL['PG_Username'] + ";" + '\n'
            sqlStr = sqlStr + "DROP TABLE IF EXISTS " + newTblName + ";" + '\n'
            sqlStr = sqlStr + "CREATE TABLE " + newTblName + "(" + '\n'
            sqlStr = sqlStr + "stid SERIAL NOT NULL," + '\n'
            insStr = "insert into " + newTblName + "(" # stid is allocated by PostGres
        elif DatabaseType == "ORA" or DatabaseType == "ORD":
            sqlStr = sqlStr + "CREATE TABLE " + newTblName + "(" + chr(141)
            sqlStr = sqlStr + "stid NUMBER Primary Key," + chr(141)
            insStr = "insert into " + newTblName + "(" # stid handled as 2nd column
        elif DatabaseType == "MSS":
            sqlStr = "DROP TABLE IF EXISTS " + newTblName + ";" + '\n'
            sqlStr = sqlStr + "CREATE TABLE " + newTblName + "(" + '\n'
            sqlStr = sqlStr + "stid int IDENTITY(1,1) NOT NULL primary key," + '\n'
            insStr = "insert into " + newTblName + "("

        fieldnames = [field.name() for field in vl.fields()]
        line = ','.join(name for name in fieldnames) + '\n'

        QGeomTypes = myGBL['QGeomTypes']
        gType = "Not Found"
        for v in QGeomTypes:
            if str(vl.wkbType()) == str(v[2]):
                gType = str(str(v[0]))

        if gType != "Not Found":
            if DatabaseType == "PGS":
                sqlStr = sqlStr + "geom geometry(" + gType + "," + tableSRID + ")," + '\n'
                insStr = insStr + "geom,"
            elif DatabaseType == "ORA" or DatabaseType == "ORD":
                sqlStr = sqlStr + "geom MDSYS.SDO_GEOMETRY," + chr(141)
                insStr = insStr + "geom,stid,"
            elif DatabaseType == "MSS":
                sqlStr = sqlStr + "geom geography," + '\n'
                insStr = insStr + "geom,"

        for field in vl.fields():

            lc_FldNm = field.name().lower()
            if DatabaseType == "PGS":
                # An "illegal" identifier has to be quoted in Postgres (and SQL).
                # The function format() has a special place holder for identifiers and will return a quoted identifier
                # if anything is non-standard:
                # So select format('%I', 'foo') returns foo.
                # But select format('%I', 'foo bar') returns "foo bar"
                oraStr = "select format('%I', '" + lc_FldNm + "')"
                oraStr = oraStr.replace("%",chr(135) + "%" + chr(135))
                oraStr = oraStr.replace(chr(135),"'||'")
                lc_FldNm = PGS_fetch1stone(oraStr, connPGS, myGBL['LogFileName'])

            if field.typeName() == "Integer64":
                if DatabaseType == "PGS":
                    sqlStr = sqlStr + lc_FldNm + " bigint," + '\n'
                elif DatabaseType == "ORA" or DatabaseType == "ORD":
                    sqlStr = sqlStr + lc_FldNm + " NUMBER(38)," + chr(141)
                elif DatabaseType == "MSS":
                    sqlStr = sqlStr + lc_FldNm + " bigint," + '\n'
            elif field.typeName() == "Integer32" or field.typeName() == "Integer":
                if DatabaseType == "PGS":
                    sqlStr = sqlStr + lc_FldNm + " integer," + '\n'
                elif DatabaseType == "ORA" or DatabaseType == "ORD":
                    sqlStr = sqlStr + lc_FldNm + " NUMBER(38)," + chr(141)
                elif DatabaseType == "MSS":
                    sqlStr = sqlStr + lc_FldNm + " int," + '\n'
            elif field.typeName() == "Integer16":
                if DatabaseType == "PGS":
                    sqlStr = sqlStr + lc_FldNm + " smallint," + '\n'
                elif DatabaseType == "ORA" or DatabaseType == "ORD":
                    sqlStr = sqlStr + lc_FldNm + " NUMBER(38)," + chr(141)
                elif DatabaseType == "MSS":
                    sqlStr = sqlStr + lc_FldNm + " smallint," + '\n'
            elif field.typeName() == "String":
                if DatabaseType == "PGS": #  + 10 as I have found GPKG strings longer than the field.length
                    sqlStr = sqlStr + lc_FldNm + " varchar(" + str(field.length() + 10) + ")," + '\n'
                elif DatabaseType == "ORA" or DatabaseType == "ORD":
                    sqlStr = sqlStr + lc_FldNm + " varchar2(" + str(field.length() + 10) + ")," + chr(141)
                elif DatabaseType == "MSS":
                    sqlStr = sqlStr + lc_FldNm + " varchar(" + str(field.length() + 10) + ")," + '\n'
            elif field.typeName() == "Date":
                if DatabaseType == "PGS":
                    sqlStr = sqlStr + lc_FldNm + " date," + '\n'
                elif DatabaseType == "ORA" or DatabaseType == "ORD":
                    sqlStr = sqlStr + lc_FldNm + " DATE," + chr(141)
                elif DatabaseType == "MSS":
                    sqlStr = sqlStr + lc_FldNm + " date," + '\n'
            elif field.typeName() == "DateTime":
                if DatabaseType == "PGS":
                    sqlStr = sqlStr + lc_FldNm + " timestamp(0) without time zone," + '\n'
                elif DatabaseType == "ORA" or DatabaseType == "ORD":
                    sqlStr = sqlStr + lc_FldNm + " TIMESTAMP," + chr(141)
                elif DatabaseType == "MSS":
                    sqlStr = sqlStr + lc_FldNm + " datetime," + '\n'
            elif field.typeName() == "Real" or field.typeName() == "Float":
                if DatabaseType == "PGS":
                    sqlStr = sqlStr + lc_FldNm + " real," + '\n'
                elif DatabaseType == "ORA" or DatabaseType == "ORD":
                    sqlStr = sqlStr + lc_FldNm + " BINARY_FLOAT," + chr(141)
                elif DatabaseType == "MSS":
                    sqlStr = sqlStr + lc_FldNm + " real," + '\n'
            elif field.typeName() == "Double" or field.typeName() == "Float32":
                if DatabaseType == "PGS":
                    sqlStr = sqlStr + lc_FldNm + " double precision," + '\n'
                elif DatabaseType == "ORA" or DatabaseType == "ORD":
                    sqlStr = sqlStr + lc_FldNm + " BINARY_DOUBLE," + chr(141)
                elif DatabaseType == "MSS":
                    sqlStr = sqlStr + lc_FldNm + " float," + '\n'
            else:
                sqlStr = sqlStr + lc_FldNm + " typeName not handled " + field.typeName() + '\n'

            insStr = insStr + lc_FldNm + ","

        if DatabaseType == "ORA" or DatabaseType == "ORD":
            sqlStr = sqlStr + ")"
            sqlStr = sqlStr.replace("," + chr(141) + ")", ")").replace(chr(141), "")
        else:
            sqlStr = sqlStr + ");"
            sqlStr = sqlStr.replace("," + '\n' + ")", ")")
        if Output2 == "File" or Output2 == "Both":
            outSQL_file.write(sqlStr.replace(chr(140),";").replace(chr(141),'\n') + '\n')
        insStr = insStr + ") values "
        insStr = insStr.replace(",)", ")")
        if Output2 == "Serv" or Output2 == "Both":
            if DatabaseType == "PGS":
                runPGSSQL(sqlStr, connPGS, myGBL['LogFileName'])
            elif DatabaseType == "ORA":
                # runORASQL(sqlStr.replace(chr(141),"") + chr(140) + '\n' + "commit" + chr(140) + '\n', connOra, myGBL['LogFileName'])
                runORASQL("DROP TABLE " + newTblName, connOra, myGBL['LogFileName'])
                runORASQL(sqlStr, connOra, myGBL['LogFileName'])
                runORASQL("commit", connOra, myGBL['LogFileName'])
            elif DatabaseType == "ORD":
                runORDSQL("DROP TABLE " + newTblName, connOrD, myGBL['LogFileName'])
                runORDSQL(sqlStr, connOrD, myGBL['LogFileName'])
                runORDSQL("commit", connOrD, myGBL['LogFileName'])
            elif DatabaseType == "MSS":
                # runDEVSQL("create schema " + myGBL['PG_Schema'] + " AUTHORIZATION " + myGBL['PG_Username'] + ";", connDEV, myGBL['LogFileName'])
                runDEVSQL(sqlStr, connDEV, myGBL['LogFileName'])


        # write feature attributes
        valStr = ""
        fromCRS = vl.sourceCrs()
        destCRS = QgsCoordinateReferenceSystem(myGBL['tableSRID'])
        ct = QgsCoordinateTransform(fromCRS, destCRS, QgsProject.instance())

        for f in vl.getFeatures():
            ncount = ncount + 1
            if ncount <= 2000:
                geom = f.geometry()

                geom.transform(ct)
                # myGBL['tableSRID'].replace("EPSG:","")

                geoStr = "NULL"
                if DatabaseType == "ORA" or DatabaseType == "ORD":
                    geoStr = "NULL," + str(ncount)
                # print (geom.asWkb())
                # geomTyp = geom.wkbType()
                didBind = False
                if (DatabaseType == "ORA" or DatabaseType == "ORD") and len(geom.asWkt()) > 4000:
                    # too long for Oracle's varchar2 client side (4000 chars) so use server side binding (327?? chars)
                    if len(geom.asWkt()) > 32700:
                        ora2Long = ora2Long + 1
                    didBind = True
                    bindSt = "/" + chr(141)
                    bindSt = bindSt + "declare" + chr(141)
                    bindSt = bindSt + " v_sql varchar2(" + str(len(geom.asWkt()) + len(newTblName) + 150) + ")" + chr(140) + chr(141)
                    bindSt = bindSt + " v_clob clob" + chr(140) + chr(141)
                    bindSt = bindSt + "begin" + chr(141)
                    bindSt = bindSt + "  v_clob := CAST('" + str(geom.asWkt()) + "' as clob)" + chr(140) + chr(141)
                    bindSt = bindSt + "  v_sql := 'insert into " + newTblName + " (stid,geom) values(:id,sdo_util.from_wktgeometry(:clob))'" + chr(140) + chr(141)
                    bindSt = bindSt + "  execute immediate v_sql" + chr(141)
                    bindSt = bindSt + "  using " + str(ncount) + ", v_clob" + chr(140) + chr(141)
                    bindSt = bindSt + "  commit" + chr(140) + chr(141)
                    bindSt = bindSt + "end" + chr(140) + chr(141)
                    bindSt = bindSt + "/" + chr(141)

                    if Output2 == "File" or Output2 == "Both":
                        outSQL_file.write(bindSt.replace(chr(140),";").replace(chr(141),'\n'))
                    if Output2 == "Serv" or Output2 == "Both":
                        if DatabaseType == "ORA":
                            runORASQL(bindSt.replace(chr(140)," ").replace(chr(141)," "), connOra, myGBL['LogFileName'])
                        if DatabaseType == "ORD":
                            runORDSQL(bindSt.replace(chr(140)," ").replace(chr(141)," "), connOrD, myGBL['LogFileName'])

                    updStr = "update " + newTblName + " set " + chr(141)
                    for field in vl.fields():
                        lc_FldNm = field.name().lower()
                        if str(f[field.name()]) == "NULL":
                            nullComment = "do not update"
                        elif field.typeName() == "Integer64":
                            updStr = updStr + lc_FldNm + "=" + str(f[field.name()]) + ","
                        elif field.typeName() == "Integer32" or field.typeName() == "Integer":
                            updStr = updStr + lc_FldNm + "=" + str(f[field.name()]) + ","
                        elif field.typeName() == "Integer16":
                            updStr = updStr + lc_FldNm + "=" + str(f[field.name()]) + ","
                        elif field.typeName() == "String":
                            # specChar = "( ) - & @ * $ | % "
                            oraStr = str(f[field.name()]).replace("'","''").replace(chr(34),chr(134))
                            oraStr = oraStr.replace("(",chr(135) + "(" + chr(135))
                            oraStr = oraStr.replace(")",chr(135) + ")" + chr(135))
                            oraStr = oraStr.replace("-",chr(135) + "-" + chr(135))
                            oraStr = oraStr.replace(".",chr(135) + "." + chr(135))
                            oraStr = oraStr.replace("&",chr(135) + "&" + chr(135))
                            oraStr = oraStr.replace("@",chr(135) + "@" + chr(135))
                            oraStr = oraStr.replace("*",chr(135) + "*" + chr(135))
                            oraStr = oraStr.replace("$",chr(135) + "$" + chr(135))
                            oraStr = oraStr.replace("|",chr(135) + "|" + chr(135))
                            oraStr = oraStr.replace("%",chr(135) + "%" + chr(135))
                            oraStr = oraStr.replace(chr(135),"'||'")
                            oraStr = oraStr.replace(chr(134),"'||'" + chr(34) + "'||'")
                            updStr = updStr + lc_FldNm + "='" + oraStr + "',"
                        elif field.typeName() == "Date":
                            DATETIME_FORMAT = 'yyyy-MM-dd'
                            qd8 = str(f[field.name()]).replace("PyQt5.QtCore.QDate","")
                            qd8 = qd8.replace(", ", "/").replace("(","").replace(")","")
                            updStr = updStr + lc_FldNm + "=" + "TO_DATE('" + qd8 + "', 'YYYY/MM/DD'),"
                        elif field.typeName() == "DateTime":
                            DATETIME_FORMAT = 'yyyy-MM-dd HH:mm:ss'
                            qd8 = str(f[field.name()]).replace("PyQt5.QtCore.QDateTime(","").replace(")","")
                            qd8 = qd8.replace(", ", "-")
                            qd8Arr = qd8.split("-")
                            # TO_DATE('2008-11-18 14:13:59', 'YYYY-MM-DD HH24:Mi:SS')
                            qd8 = qd8Arr[0] + "-" + qd8Arr[1] + "-" + qd8Arr[2]
                            if len(qd8Arr) > 3:
                                qd8 = qd8 + " " + qd8Arr[3]
                            else:
                                qd8 = qd8 + " 0"
                            if len(qd8Arr) > 4:
                                qd8 = qd8 + ":" + qd8Arr[4]
                            else:
                                qd8 = qd8 + ":0"
                            if len(qd8Arr) > 5:
                                qd8 = qd8 + ":" + qd8Arr[5]
                            else:
                                qd8 = qd8 + ":0"
                            updStr = updStr + lc_FldNm + "=" + "TO_DATE('" + qd8 + "', 'YYYY-MM-DD HH24:Mi:SS'),"                            
                        elif field.typeName() == "Real" or field.typeName() == "Float":
                            updStr = updStr + lc_FldNm + "=" + str(f[field.name()]) + ","
                        elif field.typeName() == "Double" or field.typeName() == "Float32":
                            updStr = updStr + lc_FldNm + "=" + str(f[field.name()]) + ","
                
                    updStr = updStr + ") where stid=" + str(ncount)
                    updStr = updStr.replace(",)", "")
                    if Output2 == "File" or Output2 == "Both":
                        outSQL_file.write(updStr + ";" + '\n')
                    if Output2 == "Serv" or Output2 == "Both":
                        if DatabaseType == "ORA":
                            runORASQL(updStr, connOra, myGBL['LogFileName'])
                            runORASQL("commit", connOra, myGBL['LogFileName'])
                        if DatabaseType == "ORD":
                            runORDSQL(updStr, connOrD, myGBL['LogFileName'])
                            runORDSQL("commit", connOrD, myGBL['LogFileName'])

                elif str(geom.asWkt()) != "":
                    if DatabaseType == "PGS":
                        geoStr = "st_setSRID(ST_GeomFromText('" + str(geom.asWkt()) + "')," + tableSRID + ")"
                    elif DatabaseType == "ORA" or DatabaseType == "ORD":
                        geoStr = "SDO_UTIL.FROM_WKTGEOMETRY('" + geom.asWkt() + "')," + str(ncount)
                    elif DatabaseType == "MSS":
                        geoStr = "geography::STGeomFromText('" + str(geom.asWkt()) + "'," + tableSRID + ")"
    
                if didBind == False:
                    valStr = valStr + "(" + geoStr + ","
                    for field in vl.fields():
                        if field.typeName() == "Integer64":
                            valStr = valStr + str(f[field.name()]) + ","
                        elif field.typeName() == "Integer32" or field.typeName() == "Integer":
                            valStr = valStr + str(f[field.name()]) + ","
                        elif field.typeName() == "Integer16":
                            valStr = valStr + str(f[field.name()]) + ","
                        elif field.typeName() == "String":
                            if DatabaseType == "ORA" or DatabaseType == "ORD":
                            # specChar = "( ) - & @ * $ | % "
                                oraStr = str(f[field.name()]).replace("'","''").replace(chr(34),chr(134))
                                oraStr = oraStr.replace("(",chr(135) + "(" + chr(135))
                                oraStr = oraStr.replace(")",chr(135) + ")" + chr(135))
                                oraStr = oraStr.replace("-",chr(135) + "-" + chr(135))
                                oraStr = oraStr.replace(".",chr(135) + "." + chr(135))
                                oraStr = oraStr.replace("&",chr(135) + "&" + chr(135))
                                oraStr = oraStr.replace("@",chr(135) + "@" + chr(135))
                                oraStr = oraStr.replace("*",chr(135) + "*" + chr(135))
                                oraStr = oraStr.replace("$",chr(135) + "$" + chr(135))
                                oraStr = oraStr.replace("|",chr(135) + "|" + chr(135))
                                oraStr = oraStr.replace("%",chr(135) + "%" + chr(135))
                                oraStr = oraStr.replace(chr(135),"'||'")
                                oraStr = oraStr.replace(chr(134),"'||'" + chr(34) + "'||'")
                                valStr = valStr + "'" + oraStr + "',"
                            else:                          
                                valStr = valStr + "'" + str(f[field.name()]).replace("'","''") + "',"
                        elif field.typeName() == "Date":
                            # valStr = valStr + "'" + format_date(f[field.name()],DATETIME_FORMAT) + "',"
                            DATETIME_FORMAT = 'yyyy-MM-dd'
                            # QgsExpression('format_date(f[field.name()], DATETIME_FORMAT)').evaluate(ctx)
                            # 'PyQt5.QtCore.QDate(1999, 10, 1)'
                            if str(f[field.name()]) == "NULL":
                                valStr = valStr + "NULL,"
                            else:
                                qd8 = str(f[field.name()]).replace("PyQt5.QtCore.QDate","")
                                if DatabaseType == "PGS" or DatabaseType == "MSS":
                                    qd8 = qd8.replace(", ", "-")
                                    if DatabaseType == "MSS":
                                        qd8 = qd8.replace("(", "").replace(")", "")
                                    valStr = valStr + "'" + qd8 + "',"
                                elif DatabaseType == "ORA" or DatabaseType == "ORD":
                                    qd8 = qd8.replace(", ", "/").replace("(","").replace(")","")
                                    valStr = valStr + "TO_DATE('" + qd8 + "', 'YYYY/MM/DD'),"                            
                        elif field.typeName() == "DateTime":
                            # buildtime:QgsDateTimeFieldFormatter
                            DATETIME_FORMAT = 'yyyy-MM-dd HH:mm:ss'
                            # valStr = valStr + "'" + format_date(f[field.name()],DATETIME_FORMAT) + "',"
                            if str(f[field.name()]) == "NULL":
                                valStr = valStr + "NULL,"
                            else:
                                # PyQt5.QtCore.QDateTime(2020, 8, 28, 12, 39, 52, 360)
                                # valStr = valStr + str(f[field.name()]) + ","
                                # "yyyy/mm/dd HH:mm:ss"
                                qd8 = str(f[field.name()]).replace("PyQt5.QtCore.QDateTime(","").replace(")","")
                                qd8 = qd8.replace(", ", "-")
                                qd8Arr = qd8.split("-")
                                if DatabaseType == "PGS" or DatabaseType == "MSS":
                                    qd8 = qd8Arr[0] + "-" + qd8Arr[1] + "-" + qd8Arr[2]
                                    if len(qd8Arr) > 3:
                                        qd8 = qd8 + " " + qd8Arr[3]
                                    if len(qd8Arr) > 4:
                                        qd8 = qd8 + ":" + qd8Arr[4]
                                    if len(qd8Arr) > 5:
                                        qd8 = qd8 + ":" + qd8Arr[5]
                                    if len(qd8Arr) > 6:
                                        qd8 = qd8 + "." + qd8Arr[6]
                                    valStr = valStr + "'" + qd8 + "',"

                                elif DatabaseType == "ORA" or DatabaseType == "ORD":
                                    # TO_DATE('2008-11-18 14:13:59', 'YYYY-MM-DD HH24:Mi:SS')
                                    qd8 = qd8Arr[0] + "-" + qd8Arr[1] + "-" + qd8Arr[2]
                                    if len(qd8Arr) > 3:
                                        qd8 = qd8 + " " + qd8Arr[3]
                                    else:
                                        qd8 = qd8 + " 0"
                                    if len(qd8Arr) > 4:
                                        qd8 = qd8 + ":" + qd8Arr[4]
                                    else:
                                        qd8 = qd8 + ":0"
                                    if len(qd8Arr) > 5:
                                        qd8 = qd8 + ":" + qd8Arr[5]
                                    else:
                                        qd8 = qd8 + ":0"
                                    valStr = valStr + "TO_DATE('" + qd8 + "', 'YYYY-MM-DD HH24:Mi:SS'),"                            

                        elif field.typeName() == "Real" or field.typeName() == "Float":
                            valStr = valStr + str(f[field.name()]) + ","
                        elif field.typeName() == "Double" or field.typeName() == "Float32":
                            valStr = valStr + str(f[field.name()]) + ","
                        else:
                            valStr = valStr + "new field type:" + field.typeName() 
                
                    valStr = valStr + ")"
                    # Finished looping through the fields of the current feature/record

                    # do we save these records??? Depends, lol
                    if DatabaseType == "PGS":
                        # format up a set of records once it is big enough
                        if len(valStr) > 50000:
                            valStr = valStr.replace(",)", ")").replace("'NULL'", "NULL").replace(")(st_setSRID", ")," + '\n' + "(st_setSRID")
                            valStr = valStr.replace(")(st_transform", ")," + '\n' + "(st_transform")
                            valStr = valStr.replace(")(NULL", ")," + '\n' + "(NULL")
                            if Output2 == "File" or Output2 == "Both":
                                outSQL_file.write(insStr + '\n' + valStr + ";" + '\n')
                            if Output2 == "Serv" or Output2 == "Both":
                                runPGSSQL(insStr + valStr, connPGS, myGBL['LogFileName'])
                            valStr = ""
                    elif DatabaseType == "ORA" or DatabaseType == "ORD":
                        # could not sort out how to insert multiple records per insert
                        if len(valStr) > 0:
                            valStr = valStr.replace(",)", ")").replace("'NULL'", "NULL").replace(")(SDO_UTIL", ")," + '\n' + "(SDO_UTIL")
                            valStr = valStr.replace(")(NULL", ")," + '\n' + "(NULL")
                            if Output2 == "File" or Output2 == "Both":
                                outSQL_file.write(insStr + '\n' + valStr + ";" + '\n')
                            if Output2 == "Serv" or Output2 == "Both":
                                if DatabaseType == "ORA":
                                    runORASQL(insStr + valStr.replace('\n',""), connOra, myGBL['LogFileName'])
                                if DatabaseType == "ORD":
                                    runORDSQL(insStr + valStr.replace('\n',"") + ";", connOrD, myGBL['LogFileName'])
                            valStr = ""
                    elif DatabaseType == "MSS":
                        # could not sort out how to insert multiple records per insert
                        if len(valStr) > 0:
                            valStr = valStr.replace(",)", ")").replace("'NULL'", "NULL").replace(")(geography", ")," + '\n' + "(geography")
                            valStr = valStr.replace(")(NULL", ")," + '\n' + "(NULL")
                            if Output2 == "File" or Output2 == "Both":
                                outSQL_file.write(insStr + '\n' + valStr + ";" + '\n')
                            if Output2 == "Serv" or Output2 == "Both":
                                runDEVSQL(insStr + valStr, connDEV, myGBL['LogFileName'])
                        valStr = ""


        # last group of records
        if DatabaseType == "PGS":
            valStr = valStr.replace(",)", ")").replace("'NULL'", "NULL").replace(")(st_setSRID", ")," + '\n' + "(st_setSRID")
            valStr = valStr.replace(")(st_transform", ")," + '\n' + "(st_transform")
            valStr = valStr.replace(")(NULL", ")," + '\n' + "(NULL")
            if Output2 == "File" or Output2 == "Both":
                outSQL_file.write(insStr + '\n' + valStr + '\n')
            if Output2 == "Serv" or Output2 == "Both":
                runPGSSQL(insStr + valStr, connPGS, myGBL['LogFileName'])
            valStr = ""
        elif DatabaseType == "ORA" or DatabaseType == "ORD":
            if len(valStr) > 0:
                valStr = valStr.replace(",)", ")").replace("'NULL'", "NULL").replace(")(SDO_UTIL", ")," + '\n' + "(SDO_UTIL")
                valStr = valStr.replace(")(NULL", ")," + '\n' + "(NULL")
                if Output2 == "File" or Output2 == "Both":
                    outSQL_file.write(insStr + '\n' + valStr + ";" + '\n')
                if Output2 == "Serv" or Output2 == "Both":
                    if DatabaseType == "ORA":
                        runORASQL(insStr + valStr, connOra, myGBL['LogFileName'])
                        runORASQL("commit", connOra, myGBL['LogFileName'])
                    if DatabaseType == "ORD":
                        runORDSQL(insStr + valStr, connOrD, myGBL['LogFileName'])
                        runORDSQL("commit", connOrD, myGBL['LogFileName'])
                valStr = ""
        elif DatabaseType == "MSS":
            if len(valStr) > 0:
                valStr = valStr.replace(",)", ")").replace("'NULL'", "NULL").replace(")(geography", ")," + '\n' + "(geography")
                valStr = valStr.replace(")(NULL", ")," + '\n' + "(NULL")
                if Output2 == "File" or Output2 == "Both":
                    outSQL_file.write(insStr + '\n' + valStr + ";" + '\n')
                if Output2 == "Serv" or Output2 == "Both":
                    runDEVSQL(insStr + valStr, myGBL['LogFileName'])
                valStr = ""

        if DatabaseType == "PGS":
            pgsSQL = "CREATE INDEX " + newTblName.replace(".","_") + "_spidx ON " + newTblName 
            pgsSQL = pgsSQL +" USING gist(geom);" + '\n'
            if Output2 == "File" or Output2 == "Both":
                outSQL_file.write(";" + '\n' + pgsSQL + '\n')
            if Output2 == "Serv" or Output2 == "Both":
                runPGSSQL(pgsSQL + ";", connPGS, myGBL['LogFileName'])

        if DatabaseType == "ORA" or DatabaseType == "ORD":
            oraSQL = "UPDATE " + newTblName + " T SET T.geom.SDO_SRID = " + themeSRID
            oraSQL = oraSQL +" WHERE T.geom IS NOT NULL"

            if Output2 == "File" or Output2 == "Both":
                outSQL_file.write(";" + '\n' + oraSQL + ";" + '\n' + "commit;" + '\n')
            if Output2 == "Serv" or Output2 == "Both":
                if DatabaseType == "ORA":
                    runORASQL(oraSQL, connOra, myGBL['LogFileName'])
                    runORASQL("commit", connOra, myGBL['LogFileName'])
                if DatabaseType == "ORD":
                    runORDSQL(oraSQL, connOrD, myGBL['LogFileName'])
                    runORDSQL("commit", connOrD, myGBL['LogFileName'])

            oraSQL = oraSQL + "-- CREATE INDEX " + newTblName.replace(".","_") + "_spidx ON " + newTblName + " (geom)"
            oraSQL = oraSQL + " INDEXTYPE IS MDSYS.SPATIAL_INDEX_V2"

            if Output2 == "File" or Output2 == "Both":
                outSQL_file.write(";" + '\n' + oraSQL + ";" + '\n' + "commit;" + '\n')
            if Output2 == "Serv" or Output2 == "Both":
                if DatabaseType == "ORA":
                    runORASQL(oraSQL, connOra, myGBL['LogFileName'])
                    runORASQL("commit", connOra, myGBL['LogFileName'])
                if DatabaseType == "ORD":
                    runORDSQL(oraSQL, connOrD, myGBL['LogFileName'])
                    runORDSQL("commit", connOrD, myGBL['LogFileName'])

        if DatabaseType == "MSS":
            mssSQL = "CREATE SPATIAL INDEX " + newTblName.replace(".","_") + "_geom_spidx ON " + newTblName + "(geom);" + '\n'
            if Output2 == "File" or Output2 == "Both":
                outSQL_file.write(mssSQL + '\n')
            if Output2 == "Serv" or Output2 == "Both":
                runDEVSQL(mssSQL + ";", connDEV, myGBL['LogFileName'])

        with open(os.path.expanduser( '~' ) + "/log._ImportThemeReport", 'a') as ImpLog_file:
            line = "-- " + newTblName + " has " + str(vl.featureCount()) + " features, with " + str(ncount) + " processed."
            ImpLog_file.write(line + '\n')

            if Output2 == "Serv" or Output2 == "Both":
                retCount = "?"
                if DatabaseType == "PGS":
                    retCount = PGS_fetch1stone("select count(*) from " + newTblName, connPGS, myGBL['LogFileName'])

                if DatabaseType == "ORA":
                    retCount = ORA_fetch1stone("select count(*) from " + newTblName, connOra, myGBL['LogFileName'])
                    if ora2Long > 0:
                        line = "-- *** Warning: " + newTblName + " has " + str(ora2Long) + " features that were not loaded as their geometries were too long (Over 32700 Characters)."
                        ImpLog_file.write(line + '\n')

                if DatabaseType == "ORD":
                    retCount = ORD_fetch1stone("select count(*) from " + newTblName, connOrD, myGBL['LogFileName'])
                    if ora2Long > 0:
                        line = "-- *** Warning: " + newTblName + " has " + str(ora2Long) + " features that were not loaded as their geometries were too long (Over 32700 Characters)."
                        ImpLog_file.write(line + '\n')

                if DatabaseType == "MSS":
                    retCount = DEV_fetch1stone("select count(*) from " + newTblName, connDEV, myGBL['LogFileName'])

                if retCount == "None":
                    ImpLog_file.write("An error occured getting Count(*) from " + newTblName + '\n')
                else:
                    line = "-- " + newTblName + " has " + retCount + " features saved."
                    line = line.replace("(","").replace(",)","") 
                    ImpLog_file.write(line + '\n')

            dateEnd = datetime.datetime.now()
            diffDate = (dateEnd - dateBeg).total_seconds()
            line = "Started at: " + str(dateBeg) + " and Finished at: " + str(dateEnd)
            ImpLog_file.write(line + '\n')
            if diffDate > 1:
                line = "Approx Records/Second: " + str(int(vl.featureCount() / diffDate))
                ImpLog_file.write(line + '\n')

            log_file.close
            ImpLog_file.close
            if Output2 == "Serv":
                outSQL_file.close
                os.remove(SQLFileName)

        self.iface.messageBar().pushMessage(
            "Success", "Output file written at " + SQLFileName,
            level=Qgis.Success, duration=3)

    print ("done")
    return None


def runPGSSQL(sql2Run: str, connPGS: psycopg2, LclFileName: str):
    try:
        cursor = connPGS.cursor()
        cursor.execute(sql2Run)
        connPGS.commit() 
        return True
    except Exception as error:
        with open(LclFileName, 'a') as log_file:
            log_file.write(sql2Run + '\n')
            log_file.write("Exception TYPE: " + str(type(error)) + '\n')
            error_obj = error.args
            log_file.write(str(error_obj) + '\n')
            log_file.close
    
        with open(os.path.expanduser( '~' ) + "/log.aaa", 'a') as outPGS_file:
            outPGS_file.write("Oops! An exception has occured: " + str(error) + '\n')
            outPGS_file.write("Exception TYPE: " + str(type(error)) + '\n')
            error_obj = error.args
            outPGS_file.write(str(error_obj) + '\n')
            outPGS_file.write(sql2Run + '\n')
            outPGS_file.close()
        return False

def PGS_fetch1stone(sql2Run: str, connPGS: psycopg2, LclFileName: str):
    a = PGS_fetchone(sql2Run, connPGS, LclFileName)
    return str(a[0][0]) if a else "None"

def PGS_fetchone(sql2Run: str, connPGS: psycopg2, LclFileName: str):
    # Querying data using fetchone() method
    retArr = []
    try:
        cur = connPGS.cursor()
        cur.execute(sql2Run)
        #print("The number of rows: ", cur.rowcount)
        row = cur.fetchone()

        while row is not None:
            # print(row)
            retArr.append(row)
            row = cur.fetchone()

        cur.close()
        return retArr
    except (Exception, psycopg2.DatabaseError) as error:
        with open(LclFileName, 'a') as log_file:
            log_file.write(sql2Run + '\n')
            log_file.write(str(type(error)) + '\n')
            error_obj = error.args
            log_file.write(str(error_obj) + '\n')
            log_file.close
    #finally:
    #    if connPGS is not None:
    #        connPGS.close()
    return retArr

def runORASQL(sql2Run: str, connORA: oracledb, LclFileName: str):
    try:

        cursor = connORA.cursor()
        if "drop table" in sql2Run.lower():
            with cursor.suppress(Exception):
                cursor.execute(sql2Run)
            return True

        if chr(140) in sql2Run:
            sqlArr = sql2Run.replace(chr(140),"").split('\n')
            for aSQL in sqlArr:
                cursor.execute(aSQL)
        else:
            cursor.execute(sql2Run)
        return True
    except Exception as error:
        with open(LclFileName, 'a') as log_file:
            log_file.write(sql2Run + '\n')
            log_file.write("Exception TYPE: " + str(type(error)) + '\n')
            error_obj = error.args
            log_file.write(str(error_obj) + '\n')
            log_file.close
        with open(os.path.expanduser( '~' ) + "/log.aaa", 'a') as outORA_file:
            outORA_file.write("Oops! An exception has occured: " + str(error) + '\n')
            outORA_file.write("Exception TYPE: " + str(type(error)) + '\n')
            error_obj = error.args
            outORA_file.write(str(error_obj) + '\n')
            outORA_file.write(sql2Run + '\n')
            outORA_file.close()
        return False

def ORA_fetch1stone(sql2Run: str, connORA: oracledb, LclFileName: str):
    a = ORA_fetchone(sql2Run, connORA, LclFileName)
    return str(a[0][0]) if a else "None"

def ORA_fetchone(sql2Run: str, connORA: oracledb, LclFileName: str):
    # Querying data using fetchone() method
    retArr = []
    try:
        cur = connORA.cursor()
        cur.execute(sql2Run)
        #print("The number of rows: ", cur.rowcount)
        row = cur.fetchone()

        while row is not None:
            # print(row)
            retArr.append(row)
            row = cur.fetchone()

        cur.close()
        return retArr
    except (Exception, oracledb.DatabaseError) as error:
        with open(LclFileName, 'a') as log_file:
            log_file.write(sql2Run + '\n')
            log_file.write(str(type(error)) + '\n')
            error_obj = error.args
            log_file.write(str(error_obj) + '\n')
            log_file.close
    #finally:
    #    if connORA is not None:
    #        connORA.close()
    return retArr

def runORDSQL(sql2Run: str, connORD: pyodbc, LclFileName: str):
    try:
        with open(os.path.expanduser( '~' ) + "/log.aaa", 'a') as logaaa_file:
            cursor = connORD.cursor()
            if "drop table" in sql2Run.lower():
                with cursor.suppress(Exception):
                    cursor.execute(sql2Run)
                return True

            if chr(140) in sql2Run:
                sqlArr = sql2Run.replace(chr(140),"").split('\n')
                for aSQL in sqlArr:
                    logaaa_file.write(aSQL + '\n')
                    if len(aSQL) > 5:
                        cursor.execute(aSQL)
            else:
                logaaa_file.write(sql2Run + '\n')
                cursor.execute(sql2Run)
        return True
    except Exception as error:
        with open(LclFileName, 'a') as log_fileORD:
            log_fileORD.write(sql2Run + '\n')
            log_fileORD.write("Exception TYPE: " + str(type(error)) + '\n')
            error_obj = error.args
            log_fileORD.write(str(error_obj) + '\n')
            log_fileORD.close
        with open(os.path.expanduser( '~' ) + "/log.aaa", 'a') as outORD_file:
            outORD_file.write("Oops! An exception has occured: " + str(error) + '\n')
            outORD_file.write("Exception TYPE: " + str(type(error)) + '\n')
            outORD_file.write(sql2Run + '\n')
            error_obj = error.args
            outORD_file.write(str(error_obj) + '\n')
            outORD_file.close()
        return False

def ORD_fetch1stone(sql2Run: str, connORD: pyodbc, LclFileName: str):
    a = ORD_fetchone(sql2Run, connORD, LclFileName)
    return str(a[0][0]) if a else "None"

def ORD_fetchone(sql2Run: str, connORD: pyodbc, LclFileName: str):
    # Querying data using fetchone() method
    retArr = []
    try:
        cur = connORD.cursor()
        cur.execute(sql2Run)
        #print("The number of rows: ", cur.rowcount)
        row = cur.fetchone()

        while row is not None:
            # print(row)
            retArr.append(row)
            row = cur.fetchone()

        cur.close()
        return retArr
    except (Exception, oracledb.DatabaseError) as error:
        with open(LclFileName, 'a') as log_file:
            log_file.write(sql2Run + '\n')
            log_file.write(str(type(error)) + '\n')
            error_obj = error.args
            log_file.write(str(error_obj) + '\n')
            log_file.close
    #finally:
    #    if connORD is not None:
    #        connORD.close()
    return retArr

def runDEVSQL(sql2Run: str, MSSconn: pyodbc, LclFileName: str):
    try:
        cursor = MSSconn.cursor()
        cursor.execute(sql2Run)
        MSSconn.commit() 
        return True
    except Exception as error:
        with open(LclFileName, 'a') as log_file:
            log_file.write(sql2Run + '\n')
            log_file.write("Exception TYPE: " + str(type(error)) + '\n')
            error_obj = error.args
            log_file.write(str(error_obj) + '\n')
            log_file.close
        with open(os.path.expanduser( '~' ) + "/log.aaa", 'a') as outDEV_file:
            outDEV_file.write("Oops! An exception has occured: " + str(error) + '\n')
            outDEV_file.write("Exception TYPE: " + str(type(error)) + '\n')
            outDEV_file.write(sql2Run + '\n')
            error_obj = error.args
            outDEV_file.write(str(error_obj) + '\n')
            outDEV_file.close()
        return False

def DEV_fetch1stone(sql2Run: str, connDEV: pyodbc, LclFileName: str):
    a = DEV_fetchone(sql2Run, connDEV, LclFileName)
    return str(a[0][0]) if a else "None"

def DEV_fetchone(sql2Run: str, connDEV: pyodbc, LclFileName: str):
    # Querying data using fetchone() method
    retArr = []
    try:
        cur = connDEV.cursor()
        cur.execute(sql2Run)
        #print("The number of rows: ", cur.rowcount)
        row = cur.fetchone()

        while row is not None:
            # print(row)
            retArr.append(row)
            row = cur.fetchone()

        cur.close()
        return retArr
    except (Exception, pyodbc.DatabaseError) as error:
        with open(LclFileName, 'a') as log_file:
            log_file.write(sql2Run + '\n')
            log_file.write(str(type(error)) + '\n')
            error_obj = error.args
            log_file.write(str(error_obj) + '\n')
            log_file.close
    #finally:
    #    if connDEV is not None:
    #        connDEV.close()
    return retArr


def returnPGS(**myGBL):
    return psycopg2.connect(
        host=myGBL['PG_IPAddress'],
        database=myGBL['PG_DBName'],
        user=myGBL['PG_Username'],
        password=myGBL['PG_Password'],
        port=myGBL['PG_Port'])
    # connPGS.autocommit = True
    

def returnORA(**myGBL):
    params = oracledb.ConnectParams(host=myGBL['PG_IPAddress'], port=myGBL['PG_Port'], service_name=myGBL['PG_DBName'])
    return oracledb.connect(user=myGBL['PG_Username'], password=myGBL['PG_Password'], params=params)
    
def returnORD(**myGBL):
    conStr = "DRIVER={Devart ODBC Driver for Oracle};Direct=True;Host=myServer;Service Name=myServiceName;UserID=myUsername;Port=myPort;Password=myPassword"
    conStr = conStr.replace("myServer", myGBL['PG_IPAddress'])
    conStr = conStr.replace("myServiceName", myGBL['PG_DBName'])
    conStr = conStr.replace("myPort", myGBL['PG_Port'])
    conStr = conStr.replace("myUsername", myGBL['PG_Username'])
    conStr = conStr.replace("myPassword", myGBL['PG_Password'])
    return pyodbc.connect(conStr)

def returnMSS(**myGBL):
    conStr = "DRIVER={Devart ODBC Driver for SQL Server};Server=myserver;Database=mydatabase;Port=myport;User ID=myuserid;Password=mypassword"
    conStr = conStr.replace("myserver", myGBL['PG_IPAddress'])
    conStr = conStr.replace("mydatabase", myGBL['PG_DBName'])
    conStr = conStr.replace("myport", myGBL['PG_Port'])
    conStr = conStr.replace("myuserid", myGBL['PG_Username'])
    conStr = conStr.replace("mypassword", myGBL['PG_Password'])
    return pyodbc.connect(conStr)

def my_Save_Project_File(self):
    update_myGBL(self)
    try:
        with open(myGBL['ConFileName'], 'w') as conf_file:
            line = 'host=' + self.dlg.PG_IPAddress.text() + '\n'
            line = line + 'database=' + self.dlg.PG_DBName.text() + '\n'
            line = line + 'user=' + self.dlg.PG_Username.text() + '\n'
            line = line + 'password=' + self.dlg.PG_Password.text() + '\n'
            line = line + 'port=' + self.dlg.PG_Port.text() + '\n'
            line = line + 'schemaname=' + self.dlg.PG_SchemaName.text() + '\n'
            tableSRID = str(self.dlg.mQgsProjectionSelectionWidget_Table.crs())
            tableSRID = tableSRID.replace("<QgsCoordinateReferenceSystem: ","").replace(">","")
            line = line + 'tableSRID=' + tableSRID + '\n'
            line = line + 'DatabaseType=' + myGBL['DatabaseType'] + '\n'
            line = line + 'Output2=' + myGBL['Output2'] + '\n'

            conf_file.write(line)
            conf_file.close()

        self.iface.messageBar().pushMessage(
            "Success", "Output file written at " + myGBL['ConFileName'],
            level=Qgis.Success, duration=3)

    except Exception as err:
        self.iface.messageBar().pushMessage(
        "Failure", err,
        level=Qgis.Success, duration=3)

